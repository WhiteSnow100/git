3강. Linux Fundamentals(2) [ 이언 교수 ]

학습개요
본 강의에서는 Linux File System과 사용자 권한관리, 프로세스 관리방법에 대해 알아보고자 한다. 세부적으로 Linux File들의 접근 권한 및
표기법에 대해 배워보고 이를 관리하는 방법에 대해 배워보고자 한다. 그리고 Multi-user를 지원하는 Linux에서 사용자별 권한을 어떻게 
표기하고 어떤 식으로 관리할 수 있는지를 설명하고자 한다. 마지막으로 Linux system에서의 Process에 대해 알아보고 이를 어떻게 관리할 
수 있는지 알아보고자 한다. 특히 Linux 환경에서 분석 또는 개발을 수행할 Data scientist들이 자신이 생성한 프로세스 및 프로세스에 할당된
cpu, gpu 차원을 어떻게 모니터링하고 관리할 수 있는지를 알아보고자 한다.

학습목표
1. Linux File system에서 File의 접근권한의 제어에 대해 이해한다.
2. Linux system의 사용자 접근권한의 제어에 대해 이해한다.
3. Linux system의 프로세스 관리 및 모니터링 방법에 대해 이해한다.

- Linux File System에 대하여 이해한다.
  . File 접근 권한의 제어 방법
- Linux System의 사용자 접근 권한의 제어를 이해한다.
  . 사용자 권한 관리의 목적 / 필요성 / 사용자 생성 방법
- Linux System의 프로세스 관리를 이해할 수 있다.
  . 프로세스 관리 및 모니터링 방법

학습목차
1. File System(2)
2. 사용자 관리
3. Process 관리


1. File System(2)
1-1. File의 접근 권한
- Linux에서는 파일에 무단으로 접근하는 것을 방지하고 보호하는 기능을 제공
- 사용자는 자신의 파일과 디렉터리 중에서 다른 사용자가 접근해도 되는 것과 그렇지 않은 것을 구분하여 접근 권한을 제한할 수 있음.
- 파일 권한 표기 방식
  . 문자 표기 방식
  . 숫자 표기 방식

1-2. File의 접근 권한 - 문자 표기 방식
- 사용자 카테고리별로 누가 파일을 읽고 쓰고 실행할 수 있는지를 문자로 표현
- 파일의 접근권한은 읽기(r), 쓰기(w), 실행(x) 등 총 3가지로 구성됨
- 사용자 카테고리별로 세 가지의 권한부여 여부를 rwx 세 문자를 묶어서 표기
  권한     |  File                                          |  Directory
  읽기(r)  | 파일을 읽거나 복사할 수 있음.           | ls 명령으로 Directory목록을 볼 수 있음
  쓰기(w) | 파일을 수정, 이동, 삭제할 수 있음       | 파일을 생성하거나 삭제할 수 있음.
            | (Directory 내 쓰기 권한이 있어야 함)   |
  실행(x)  | 파일을 실행할 수 있음                     | cd 명령을 사용할 수 있음. 파일을 Directory로 
            | (Shell script 나 실행파일의 경우)        |  이동하거나 복사할 수 있음

1-3. File의 접근 권한 표기 방법
1-3-1. 접근권한 표기법
- rw-       r--      r--
  소유자   그룹    기타사용자
- 9자리로 구성
- 3자리씩 끊어 파일의 권한에 관련된 내용을 표기
- 자리별로 rwx 권한 소유여부를 나타냄

1-3-2. 접근 권한별 의미
접근권한  |   의미
rwxr-xr-x  | 소유자는 읽기, 쓰기, 실행 권한을 모두 가지고 있고 그룹과 기타 사용자는 읽기와 실행 권한만 가지고 있음
r-xr-xr-x   | 소유자, 그룹, 기타 사용자 모두 읽기와 실행 권한만 가지고 있음
rw-------  | 소유자만 읽기, 쓰기 권한을 가지고 있고 나머지는 아무 권한이 없음
rw-rw-rw- | 소유자, 그룹, 기타 사용자 모두 읽기와 쓰기 권한을 가지고 있음
rwxrwxrwx | 소유자, 그룹, 기타 사용자 모두 읽기, 쓰기, 실행 권한을 가지고 있음
rwx------  | 소유자만 읽기, 쓰기, 실행 권한을 가지고 있고 그룹과 기타 사용자는 아무런 권한이 없음
r---------  | 소유자만 읽기 권한을 가지고 있음

1-4. File의 접근 권한 변경
1-4-1. chmod [옵션][권한변경내용][대상파일/디렉토리]
- 파일이나 디렉터리의 접근 권한을 변경함
- -R 옵션으로 하위 디렉토리까지 모두 변경 가능
- 접근권한 변경 방식
  . 기호 모드 : 접근 권한을 변경하기 위해 문자와 기호를 사용하여 권한을 표시
  . 숫자 모드 : 접근 권한을 사용하기 위해 숫자를 사용

1-5. File의 접근 권한 변경 예시 - 기호모드
1-5-1. 기호를 사용한 파일 접근 권한 변경
권한표기 | 의미                                             | 권한표기   |  의미
u+w      | 소유자(u)에게 쓰기(w) 권한 부여(+)        | +wx         | 모든 사용자에게 쓰기(w)와 실행(x) 권한 부여(+)
u-x        | 소유자(u)의 실행(x) 권한 제거(-)            | a+wx       | 모든 사용자에게 읽기(r), 쓰기(w), 실행(x) 권한 부여(+)
g+w      | 그룹(g)에 쓰기(w) 권한 부여(+)              | u+rwx     | 소유자(u)에게 읽기(r), 쓰기(w), 실행(x) 권한 부여(+)
o-r        | 기타 사용자(o)의 읽기(r) 권한 제거         | go+w      | 그룹(g)과 기타 사용자(o)에게 쓰기(w) 권한 부여(+)
g+wx     | 그룹(g)에 쓰기(w)와 실행(x) 권한 부여(+)  | u+x,go+w | 소유자(u)에게 실행(x) 권한 부여(+), 그룹(g)과 기타 사용자(o)에게 쓰기(w) 권한 부여(+)
 
--> ls -l
--> rw-rw-r--    # 현재 접근 권한 확인 - 파일 접근 권한 확인 
--> chmod u-w test
--> ls -l
--> r--rw-r--   # 소유자의 쓰기 권한을 제거 - 파일 권한 변경 

1-6. File의 접근 권한 변경 예시 - 숫자표기 방식
- 소유자  그룹권한  기타사용자권한
- rwx      rw-        r--     : 권한이 있으면 1, 없으면 0
- 111     110        100   : 2진수
- 7        6           4     : 8진수


2. 사용자 관리
2-1. 사용자/그룹 계정 관리 필요성
- Linux 는 multi user를 지원하는 운영체제
- 사용자마다 ID라고 불리는 고유의 식별자 필요
- 각 사용자는 적어도 하나의 그룹에 속하게 되고 각각의 그룹은 그룹 ID에 의해 구분이 됨
  . User별(계정별)로 ID(호수) / PW(비밀번호)가 있어야 출입 및 권한 관리 가능
  . User들 끼리의 그룹을 결정해 공통의 권한을 부여 및 관리

2-2. root 계정
- root계정은 Linux시스템에서 가장 강력한(모든) 권한을 갖는 계정
  . 근본적으로 시스템을 관리할 수 있는 계정은 root 단 하나뿐임
  . root 계정은 어떠한 보안상의 제약도 가해지지 않음
- Root권한을 사용하는 방법(root계정의 패스워드를 알아야 함)
  . root계정에 login 하여 명령을 수행
  . sudo명령을 사용하고자하는 명령어 앞에 붙여 root권한으로 해당 명령어를 실행

--> apt-get update  # 레파지토리 update로 permission denied 오류발생
--> sudo apt-get update  # sudo로 똑같은 명령어 실행시 ok

2-3. 사용자 계정 구성
2-3-1. 계정의 표기법
- root:X:0:0:root:/root:/bin/ash
- 사용자계정:패스워드:UID:GID:comment:homedirectory:shell

- 7가지 항목으로 구성됨
  . 사용자 계정명, 패스워드, UID, GID, comment, home, shell

- 사용자계정 : 사용자 고유의 계정
- 패스워드 
  . 사용자의 패스워드
  . 새로운 계정을 추가할 때 지정해준 패스워드를 'x'로 변환해 저장
- UID : User IDentification
  . Linux 시스템이 사용하는 User의 ID
  . UID 중 0 ~ 99까지는 root(UID 0)나 그 외의 시스템 관리상 필요한 특별한 사용자에게 할당
  . 일반 사용자는 1000번부터 사용
- GID : Group IDentification
  . Group의 ID
  . Linux 시스템 내 사용자가 속한 그룹의 신분증
  . 많은 사람이 Linux 사용 목적 및 권한에 따라 같은 GID를 사용하게 됨
    + ex1 : 분석가 group 이라 data 폴더의 파일 삭제 권한 제외
    + ex2 : 분석 환경 생성을 위해 Docker group에 user추가
- comment : user의 간단한 정보 기록
- Home directory
  . 사용자 계정의 기본 directory/login 시 처음으로 지정되는 directory(절대경로)
  --> 기본적으로 /Home/USERID 로 지정됨
- shell
  . 사용자가 로그인 했을 때, 활성화 되는 최초의 shell을 의미(ex: zsh, bash, ash, etc)

2-4. 사용자/그룹 계정 관리
- Linux에서 사용자 및 그룹 /etc/passwd, /etc/group에서 관리됨

2-5. 사용자 관리
- 사용자 관리에는 기본적으로 root 권한이 필요
  . 필요시 시스템 관리자에게 요청
  . 주요 관리 기능은 사용자 추가, 권한 확인, 사용자 변경이 있음

2-6. 사용자 관리 - 사용자 추가
2-6-1. useradd/adduser
- useradd : 사용자 계정만 만들고 기타 설정은 수행하지 않음 - 7가지+α정보가 기입되지 않음.
- adduser : 적절한 UID/GID를 자동으로 선정하고 홈 Directory를 생성. 사용자 기본설정을 복사(주로 사용)

2-6-2. id
- 현재 login 된 user의 권한을 확인

2-7. 사용자 관리 - 사용자 변경(switch user)
2-7-1. su [ 사용자 계정 ]
- Logout을 하지 않고 지정된 계정으로 login
- su 명령어를 통해 계정간 이동이 가능

2-8. 그룹 계정 관리
- 그룹(Group) : 사용자의 계정들을 모아서 하나의 집합을 이루는 개념
- 그룹계정
  . 그룹 별로 할당된 권한으로 그룹에 속한 모든 계정에 권한을 추가 및 수정
  . bin, mail, sys등 몇 가지의 시스템 정의 그룹에는 포함될 수 없음.

2-8-1. 그룹계정관리 - 그룹 추가
- groupadd [옵션][그룹명]
  . 새로운 그룹을 생성
  . 개별 사용자를 추가하는 것과 비슷함
  . root권한으로 groupadd 명령어를 사용
  . 현재 자신이 속한 group을 확인하고자 한다면 groups 명령어를 사용


3. Process 관리
3-1. 프로세스의 개념
- 프로세스 : 프로그램이 메모리에 적재되어 실제로 실행되고 있는 상태
  . 현재 시스템에서 실행중인 프로그램으로 이해할 수 있음
- 모든 프로그램은 실행될 때 하나 이상의 프로세스를 가짐
- 프로세스의 부모-자식 관계
  . 프로세스는 부모-자식 관계를 가지고 있음
  . 필요에 따라 부모 프로세스(parent process)는 자식 프로세스(child process)를 생성하고, 
    자식 프로세스는 또 다른 자식 프로세스 생성 가능
  . 자식 프로세스는 할 일이 끝나면 부모 프로세스에 결과를 돌려주고 종료

- 프로세스의 번호(Process ID)
  . PID : 각 프로세스가 가지는 고유한 번호
  . 각각이 프로세스마다 고유 번호의 프로세스 ID(PID)를 하나씩 증가하면서 부여
  . 더 이상 할당할 PID가 없으면, 사용되지 않는 가장 낮은 숫자가 되돌아가 다시 pid를 할당함
  --> ps   

3-2. 프로세스의 상태
- 프로세스의 상태는 생성, 실행, 준비, 대기, 종료가 있음
- 프로세스의 "실행"상태는 프로세스가 CPU를 차지하고 있는 상태를 의미
  . 프로세스가 실행중인 상태에서 ctrl+z를 누르면 실행을 중지 시킬 수 있음.
상태 | 의미
R     | 프로세스가 실행중 또는 실행 가능한 상태  //모니터링하는곳에서 확인가능
Z     | 프로세스가 종료되었지만 부모프로세스가 먼저 종료된 좀비* 상태
T     | 정지된 상태(suspend)
S     | 인터럽트를 기다리는 휴먼 상태(sleeping)  
D     | 인터럽트가 될 수 없는 대기 상태(uninterruptible sleep)
* 좀비 프로세스 : 실행이 끝났는데도 종료되지 못하고 메모리상에 남아 있는 프로세스

3-3. 프로세스 관리 - ps
3-3-1. ps [옵션]
- 현재 실행중인 프로세스에 대한 정보를 출력
- ps 명령을 옵션없이 사용하면 현재 셀이나 실행한 사용자 프로세스에 대한 정보를 모두 출력함.
- 옵션을 통해 다양한 프로세스 정보를 모니터링 할 수 있음.

3-3-2. ps -f
- 프로세스 상세 목록 보기
- 프로세스의 상세한 정보를 출력 : PPID, 터미널 번호, 시작 시간 등
항목    |  의미
UID     | 프로세스를 실행한 사용자 ID
PID     | 프로세스 ID
PPID    | 부모 프로세스 번호
C        | CPU 사용량(%)
STIME  | 프로세스 시작시간이나 날짜
TTY     | 프로세스가 실행된 터미널의 종류와 번호
TIME    | 프로세스 실행시간
CMD    | 실행되고 있는 command

3-3-3. ps -p [PID]
- 프로세스 특정 목록 보기
- -p 옵션과 함께 특정 PID를 지정하면 해당 프로세스의 정보를 출력

3-3-4. ps [옵션] | grep [검색]
- ps명령을 이용해 특정 프로세스 정보 검색
- grep명령을 |(vertical bar)로 연결해 특정 프로세스에 대한 정보 검색(파이프)
--> PIPF, IORedirection 이용
--> ps -f | grep bash  
--> bash로 실행된 프로세스만 보겠다.

3-4. 프로세스 관리 - kill
3-4-1. kill [시그널] [PID]
- 지정한 시그널을 프로세스에 보냄
- 시그널 : -2(인터럽트), -9(강제종료), -15(파일 정리후 종료)
- 프로세스가 종료되지 않는 경우 -9시그널을 활용해 강제종료를 수행함.

3-5. 프로세스 관리 - top
3-5-1. top [옵션]
- 프로세스 모니터링 명령어
- 현재 실행중인 프로세스에 대한 정보를 주기적으로 출력
- 윈도우의 작업관리자와 비슷한 역할을 함.
항목          |  의미
PID           | 프로세스 ID
USER         | 사용자 계정
PR            | 우선순위
NI             | 프로세스 Nice* 값
VIRT          | 프로세스가 사용하는 가상 메모리 크기
RES           | 프로세스가 사용하는 메모리 크기
SHR          | 프로세스가 사용하는 공유 메모리 크기
%CPU        | CPU 사용량
%MEM       | 메모리 사용량
TIME+        | CPU누적 이용 시간
COMMAND | Command 이름
*nice 값은 프로세스가 얼마나 친절한지(?)를 지정, nice값은 -20에서 19사이에 값을 지정할 수 있으며,
작은 값을 가질 수 록 더 많은 cpu지원을 쓰게 스케줄링함. 기본적으로 손대지 않으면 0값을 가짐

3-6. 프로세스 관리 - htop
3-6-1. htop [옵션]
- top과 유사하지만 시각화가 더욱 잘되어 있는 모니터링 툴(추가설치필요)
- 다양한 단축키를 지원
- core별 사용량을 따로 표기해 디테일한 모니터링 가능
항목 |  의미
F1    | Help, 단축키 기능 확인
F2    | Setup, htop 설정 메뉴
F3    | Search, 프로세스 검색
F4    | Filter, 프로세스 필터링
F5    | Tree, 부모-자식 관계 확인가능
F6    | Sort, 정렬(Sort by 기준 선택)
F7    | Nice(+) , 우선순위 올림
F8    | Nice(-), 우선순위 내림
F9    | Kill, 프로세스 종료
F10   | htop 종료

3-7. 프로세스 관리 - nvidia-smi
3-7-1. nvidia-smi
- GPU의 상태(사용량, 온도, 드라이브 버젼 등)을 체크
- GPU Process ID를 확인
  . Driver version : 사용하고 있는 GPU_Driver version
  . CUDA Version : 사용하고 있는 CUDA_version // 연산을 사용하는 곳
  . GPU/FAN : 0~7까지는 GPU_number이며 N/A가 표기 된곳은 Fan이 장착 되어 있는 GPU사용시 사용 %로 표기
  --> 8개의 gpu card가 들어있는 server
  . name : GPU CARD(tesla v100)
    - persistence-m : off- 파워지속성 모드. default는 off. on으로 변경시 nvidia-smi -pm 1 & nvida-smi -p 1 70 파워제한을 걸 수 있음
    --> gpu가 내가 사용할 전력에 대해 control
    - Temp : GPU온도 일정 온도가 지나면 성능 저하 및 gpu drop이 발생
    - Pwr : usage/cap : gpu의 전력 usage. 현재 사용량과 / cap 최대용량
  . memory-usage : GPU별 gpu_memory, 2744MiB사용중이고 16130MiB가 gpu total memory
  . Volatile GPU-util : GPU 성능치
  . Processes : GPU 0~7번 PID process ID 등 현재 사용중인 Process ID 확인이 가능
  --> ps 명령어와 같음


정리하기
- 파일의 권한 관리
  . 파일의 접근권한의 구성
  . 접근권한 표기법 이해, 접근권한 제어(기호식) 방법(rwx)
  . 파일 접근권한 수정 방법(chmod)
- 사용자 관리
  . 사용자 / 그룹의 개념 이해
  . 사용자 계정 구성 / 사용자 추가
- 프로세스 관리
  . 프로세스의 이해
  . 프로세스 관리 방법 : ps, top, htop, kill 명령어


1. Linux에서 파일의 접근권한은 사용자 카테고리별로 누가 파일을 쓰고 실행할 수 있는지를 문자로 표현한 것이다.
   r(Read), w(Write), x(eXecute) 와 같은 기호를 통해 owner, group 기타 user의 파일의 접근권한을 표기한다.
  파일의 접근권한을 변경하기 위해서는 chmod명령을 사용해야 한다.
2. Linux는 여러명의 사용자가 동시에 접속하여 사용하는 multi-user 시스템이다. 따라서 그 여러명의 사요자 각각
   접근할 수 있는 영역이나 파일등을 관리해야 할 필요서이 있으므로 각 계정에 따른 권한이 어떻게 구성되어 있으며
   사용자/그룹 추가(useradd/adduser/groupadd) 및 권한 관리를 어떤 방식으로 할 수 있는지를 알아야 한다.
3. Linux의 프로세스는 현재 시스템에서 실행중인 프로그램으로 이해할 수 있으며 ps 명령어를 사용해 현재 실행중인
   프로세스의 정보를 확인할 수 있다(다양한 옵션으로 원하는 프로세스를 필터링할 수 있음). 세부적인 모니터링을 위해서는
   top, htop 명령으로 프로세스의 세부정보 및 자원 할당 정도를 확인할 수 있으며, gpu 프로세스를 모니터링하기 
   위해서는 nvidia-smi 명령으로 확인이 가능하다.
